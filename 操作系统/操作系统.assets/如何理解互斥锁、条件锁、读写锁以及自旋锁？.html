<span class="RichText ztext CopyrightRichText-richText" itemprop="text"><p>这个问题不错，锁是一个常见的同步概念，我们都听说过加锁（lock）或者解锁（unlock），当然学术一点地说法是获取（acquire）和释放（release）。</p><figure data-size="normal"><noscript>&lt;img src="https://pic1.zhimg.com/50/v2-b41c6cfeb6bfdb84480e7f9fc0c4761b_hd.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="998" data-rawheight="262" data-default-watermark-src="https://pic4.zhimg.com/50/v2-36cf247f90fa702e670b92ea8bbeb5aa_hd.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="998" data-original="https://pic4.zhimg.com/v2-b41c6cfeb6bfdb84480e7f9fc0c4761b_r.jpg?source=1940ef5c"/&gt;</noscript><img src="https://pic1.zhimg.com/80/v2-b41c6cfeb6bfdb84480e7f9fc0c4761b_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="998" data-rawheight="262" data-default-watermark-src="https://pic4.zhimg.com/50/v2-36cf247f90fa702e670b92ea8bbeb5aa_hd.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb lazy" data-original="https://pic4.zhimg.com/v2-b41c6cfeb6bfdb84480e7f9fc0c4761b_r.jpg?source=1940ef5c" data-actualsrc="https://pic1.zhimg.com/50/v2-b41c6cfeb6bfdb84480e7f9fc0c4761b_hd.jpg?source=1940ef5c" data-lazy-status="ok" width="998"></figure><p>恰好pthread包含这几种锁的API，而C++11只包含其中的部分。接下来我将通过pthread的API来展开回答。</p><h2>mutex（互斥量）</h2><p>mutex（mutual   exclusive）即互斥量（互斥体）。也便是常说的互斥锁。<br>尽管名称不含lock，但是称之为锁，也是没有太大问题的。mutex无疑是最常见的多线程同步方式。其思想简单粗暴，多线程共享一个互斥量，然后线程之间去竞争。得到锁的线程可以进入临界区执行代码。</p><div class="highlight"><pre><code class="language-c"><span class="c1">// 声明一个互斥量    
</span><span class="c1"></span><span class="n">pthread_mutex_t</span> <span class="n">mtx</span><span class="p">;</span>
<span class="c1">// 初始化 
</span><span class="c1"></span><span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="c1">// 加锁  
</span><span class="c1"></span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
<span class="c1">// 解锁 
</span><span class="c1"></span><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
<span class="c1">// 销毁
</span><span class="c1"></span><span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span> </code></pre></div><p class="ztext-empty-paragraph"><br></p><p>mutex是睡眠等待（sleep waiting）类型的锁，当线程抢互斥锁失败的时候，线程会陷入休眠。优点就是节省CPU资源，缺点就是休眠唤醒会消耗一点时间。另外自从Linux 2.6版以后，mutex完全用futex的API实现了，内部系统调用的开销大大减小。</p><p>值得一提的是，pthread的锁一般都有一个trylock的函数，比如对于互斥量：</p><div class="highlight"><pre><code class="language-c"><span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 加锁成功
</span><span class="c1"></span>    <span class="p">...</span> 
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">EBUSY</span> <span class="o">==</span> <span class="n">ret</span><span class="p">){</span> <span class="c1">// 锁正在被使用;
</span><span class="c1"></span>    <span class="p">...</span> 
<span class="p">}</span></code></pre></div><p>pthread_mutex_trylock用于以非阻塞的模式来请求互斥量。就好比各种IO函数都有一个noblock的模式一样，对于加锁这件事也有类似的非阻塞模式。</p><p>当线程尝试加锁时，如果锁已经被其他线程锁定，该线程就会阻塞住，直到能成功acquire。但有时候我们不希望这样。pthread_mutex_trylock在被其他线程锁定时，会返回特殊错误码。加锁成返回0，仅当成功但时候，我们才能解锁在后面进行解锁操作！</p><p>C++11开始引入了多线程库&lt;thread&gt;，其中也包含了互斥锁的API：<b>std::muxtex</b> 。</p><p>此外，依据同一线程是否能多次加锁，把互斥量又分为如下两类：</p><ul><li>是：称为『递归互斥量』recursive mutex ，也称『<b>可重入锁</b>』reentrant lock</li><li>否：即『非递归互斥量』non-recursive mute），也称『<b>不可重入锁</b>』non-reentrant mutex</li></ul><p>若同一线程对非递归的互斥量多次加锁，可能会造成死锁。递归互斥量则无此风险。C++11中有递归互斥量的API：<b>std::recursive_mutex</b>。对于pthread则可以通过给mutex添加PTHREAD_MUTEX_RECURSIVE 属性的方式来使用递归互斥量：</p><div class="highlight"><pre><code class="language-c"><span class="c1">// 声明一个互斥量
</span><span class="c1"></span><span class="n">pthread_mutex_t</span> <span class="n">mtx</span><span class="p">;</span>
<span class="c1">// 声明一个互斥量的属性变量
</span><span class="c1"></span><span class="n">pthread_mutexattr_t</span> <span class="n">mtx_attr</span><span class="p">;</span>

<span class="c1">// 初始化互斥量的属性变量
</span><span class="c1"></span><span class="n">pthread_mutexattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx_attr</span><span class="p">);</span>
<span class="c1">// 设置递归互斥量的属性
</span><span class="c1"></span><span class="n">pthread_mutexattr_settype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx_attr</span><span class="p">,</span> <span class="n">PTHREAD_MUTEX_RECURSIVE</span><span class="p">);</span>

<span class="c1">// 把属性赋值给互斥量
</span><span class="c1"></span><span class="n">pthread_mutext_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutext_attr</span><span class="p">);</span></code></pre></div><p>然而对于<b>递归互斥量</b>或者说<b>可重入锁</b>的使用则需要克制。Stevens大神生前在《APUE》中说『使用好它是十分tricky的，仅当没有其他解决方案时才使用』<sup data-text="1" data-url="https://en.wikipedia.org/wiki/Reentrant_mutex#Practical_use" data-numero="1" data-draft-node="inline" data-draft-type="reference" data-tooltip="1 https://en.wikipedia.org/wiki/Reentrant_mutex#Practical_use" data-tooltip-preset="white" data-tooltip-classname="ztext-referene-tooltip"><a id="ref_1_0" href="#ref_1" data-reference-link="true" aria-labelledby="ref_1">[1]</a></sup>。</p><p>可重入锁这个概念和称呼的走俏多半是Java语言的功劳。</p><h2>condition variable（条件变量）</h2><p>题主所谓的条件锁，我猜指的应该是条件变量。请注意条件变量不是锁，它是一种线程间的通讯机制，并且几乎总是和互斥量一起使用的。所以互斥量和条件变量二者一般是成套出现的。比如C++11中也有条件变量的API： <b>std::condition_variable</b>。</p><p>对于pthread：</p><div class="highlight"><pre><code class="language-c"><span class="c1">// 声明一个互斥量     
</span><span class="c1"></span><span class="n">pthread_mutex_t</span> <span class="n">mtx</span><span class="p">;</span>
<span class="c1">// 声明一个条件变量
</span><span class="c1"></span><span class="n">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// 初始化 
</span><span class="c1"></span><span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// 加锁  
</span><span class="c1"></span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
<span class="c1">// 加锁成功，等待条件变量触发
</span><span class="c1"></span><span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>

<span class="p">...</span>
<span class="c1">// 加锁  
</span><span class="c1"></span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
<span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
<span class="p">...</span>

<span class="c1">// 解锁 
</span><span class="c1"></span><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
<span class="c1">// 销毁
</span><span class="c1"></span><span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span></code></pre></div><p>pthread_cond_wait函数会把条件变量和互斥量都传入。并且多线程调用的时候条件变量和互斥量一定要一一对应，不能一个条件变量在不同线程中wait的时候传入不同的互斥量。否则是未定义结果。</p><p>关于是先解锁互斥量还是先进行条件变量的通知，是另外一个比较大的议题。有种论断说：先解锁互斥量再通知条件变量可以减少多余的上下文切换，进而提高效率。这种说法是基于一种实现假设：先通知条件变量，再解锁。可能让其他等待条件变量的线程被唤醒了，但是此时互斥量还没解锁，从而再次陷入休眠。然而对于另外一些实现，比如Linux系统，则通过等待变形（<b>wait morphing</b>）<sup data-text="2" data-url="https://books.google.com.hk/books?id=Ps2SH727eCIC&amp;pg=PA647&amp;lpg=PA647&amp;dq=linux+programming+interface+wait+morphing&amp;source=bl&amp;ots=kMKcz2zPC7&amp;sig=ACfU3U1ZSbxBegrQhuVkfNAMTRkY-YavvA&amp;hl=en&amp;sa=X&amp;redir_esc=y&amp;hl=zh-CN&amp;sourceid=cndr#v=onepage&amp;q=linux%20programming%20interface%20wait%20morphing&amp;f=false" data-numero="2" data-draft-node="inline" data-draft-type="reference" data-tooltip="2 https://books.google.com.hk/books?id=Ps2SH727eCIC&amp;pg=PA647&amp;lpg=PA647&amp;dq=linux+programming+interface+wait+morphing&amp;source=bl&amp;ots=kMKcz2zPC7&amp;sig=ACfU3U1ZSbxBegrQhuVkfNAMTRkY-YavvA&amp;hl=en&amp;sa=X&amp;redir_esc=y&amp;hl=zh-CN&amp;sourceid=cndr#v=onepage&amp;q=linux%20programming%20interface%20wait%20morphing&amp;f=false" data-tooltip-preset="white" data-tooltip-classname="ztext-referene-tooltip"><a id="ref_2_0" href="#ref_2" data-reference-link="true" aria-labelledby="ref_2">[2]</a></sup>解决了这一问题。所以先通知再解锁也没用问题。</p><p class="ztext-empty-paragraph"><br></p><p><b>另外在使用条件变量的过程中有个稍微违反直觉的写法</b>：那就是使用while而不是if来做判断状态是否满足。这样做的原因有二：</p><ol><li>避免惊群；</li><li>避免某些情况下线程被<b>虚假唤醒</b>（即没有pthread_cond_signal就解除了阻塞）。</li></ol><p>比如<b>半同步/半reactor</b>的网络模型中，在工作线程消费fd队列的时候：</p><div class="highlight"><pre><code class="language-c"><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 加锁
</span><span class="c1"></span>        <span class="p">...</span> <span class="c1">// 异常逻辑
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">...</span> <span class="c1">// 异常逻辑
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 解锁
</span><span class="c1"></span>        <span class="p">...</span> <span class="c1">// 异常逻辑
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">process</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="c1">// 处理流程，业务逻辑
</span><span class="c1"></span><span class="p">}</span></code></pre></div><p>以上伪码摘自我的文章：</p><a target="_blank" href="https://zhuanlan.zhihu.com/p/58860015" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-35f9401a1da7d14a41e22496b13d1bed_180x120.jpg" data-image-width="750" data-image-height="530" class="LinkCard old LinkCard--hasImage" data-za-detail-view-id="172"><span class="LinkCard-backdrop" style="background-image:url(https://pic2.zhimg.com/v2-35f9401a1da7d14a41e22496b13d1bed_180x120.jpg)"></span><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">果冻虾仁：高山仰之可极，谈半同步/半异步网络并发模型</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>zhuanlan.zhihu.com</span></span><span class="LinkCard-imageCell"><img class="LinkCard-image LinkCard-image--horizontal" alt="图标" src="https://pic2.zhimg.com/v2-35f9401a1da7d14a41e22496b13d1bed_180x120.jpg"></span></span></a><h2>read-write lock（读写锁）</h2><p>顾名思义『读写锁』就是对于临界区区分读和写。在读多写少的场景下，不加区分的使用互斥量显然是有点浪费的。此时便该上演读写锁的拿手好戏。</p><p>读写锁有一个别称叫『共享-独占锁』。不过单看『共享-独占锁』或者『读写锁』这两个名称，其实并未区分对于读和写，到底谁共享，谁独占。可能会让人误以为读写锁是一种更为泛化的称呼，其实不是。读写锁的含义是准确的：是一种 读共享，写独占的锁。</p><p>读写锁的特性：</p><ul><li>当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会<b>阻塞</b>（不是失败）。</li><li>当读写锁被加了读锁时，其他线程对该锁加写锁会<b>阻塞</b>，加读锁会成功。</li></ul><p>因而适用于多读少写的场景。</p><div class="highlight"><pre><code class="language-c"><span class="c1">// 声明一个读写锁
</span><span class="c1"></span><span class="n">pthread_rwlock_t</span> <span class="n">rwlock</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// 在读之前加读锁
</span><span class="c1"></span><span class="n">pthread_rwlock_rdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>

<span class="p">...</span> <span class="err">共享资源的读操作</span>

<span class="c1">// 读完释放锁
</span><span class="c1"></span><span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>

<span class="c1">// 在写之前加写锁
</span><span class="c1"></span><span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span> 

<span class="p">...</span> <span class="err">共享资源的写操作</span>

<span class="c1">// 写完释放锁
</span><span class="c1"></span><span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span>

<span class="c1">// 销毁读写锁
</span><span class="c1"></span><span class="n">pthread_rwlock_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">);</span></code></pre></div><p>其实加读锁和加写锁这两个说法可能会造成误导，让人误以为是有两把锁，其实读写锁是一个锁。所谓加读锁和加写锁，准确的说法可能是『给读写锁加读模式的锁定和加写模式的锁定』。</p><p>读写锁和互斥量一样也有trylock函数，也是以非阻塞地形式来请求锁，不会导致阻塞。</p><div class="highlight"><pre><code class="language-c"> <span class="n">pthread_rwlock_tryrdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">)</span>
 <span class="n">pthread_rwlock_trywrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">)</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p>C++11中有互斥量、条件变量但是并没有引入读写锁。而在C++17中出现了一种新锁：<b>std::shared_mutex</b>。用它可以模拟实现出读写锁。demo代码可以直接参考cppreference：</p><a target="_blank" href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/thread/shared_mutex" data-draft-node="block" data-draft-type="link-card" class="LinkCard old LinkCard--noImage" data-za-detail-view-id="172"><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">std::shared_mutex - cppreference.com</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>en.cppreference.com</span></span><span class="LinkCard-imageCell"><div class="LinkCard-image LinkCard-image--default"><svg class="Zi Zi--Browser" fill="currentColor" viewBox="0 0 24 24" width="32" height="32"><path d="M11.991 3C7.023 3 3 7.032 3 12s4.023 9 8.991 9C16.968 21 21 16.968 21 12s-4.032-9-9.009-9zm6.237 5.4h-2.655a14.084 14.084 0 0 0-1.242-3.204A7.227 7.227 0 0 1 18.228 8.4zM12 4.836A12.678 12.678 0 0 1 13.719 8.4h-3.438A12.678 12.678 0 0 1 12 4.836zM5.034 13.8A7.418 7.418 0 0 1 4.8 12c0-.621.09-1.224.234-1.8h3.042A14.864 14.864 0 0 0 7.95 12c0 .612.054 1.206.126 1.8H5.034zm.738 1.8h2.655a14.084 14.084 0 0 0 1.242 3.204A7.188 7.188 0 0 1 5.772 15.6zm2.655-7.2H5.772a7.188 7.188 0 0 1 3.897-3.204c-.54.999-.954 2.079-1.242 3.204zM12 19.164a12.678 12.678 0 0 1-1.719-3.564h3.438A12.678 12.678 0 0 1 12 19.164zm2.106-5.364H9.894A13.242 13.242 0 0 1 9.75 12c0-.612.063-1.215.144-1.8h4.212c.081.585.144 1.188.144 1.8 0 .612-.063 1.206-.144 1.8zm.225 5.004c.54-.999.954-2.079 1.242-3.204h2.655a7.227 7.227 0 0 1-3.897 3.204zm1.593-5.004c.072-.594.126-1.188.126-1.8 0-.612-.054-1.206-.126-1.8h3.042c.144.576.234 1.179.234 1.8s-.09 1.224-.234 1.8h-3.042z"></path></svg></div></span></span></a><p class="ztext-empty-paragraph"><br></p><p>另外多读少写的场景有些特殊场景，可以用特殊的数据结构减少锁使用：</p><ul><li>多读单写的线性数据。<b>用数组实现环形队列</b>，避免vector等动态扩张的数据结构，写在结尾，由于单写因而可以不加锁；读在开头，由于多读（避免重复消费）所以需要加一下锁（互斥量就行）。</li><li>多读单写的KV。<b>可以使用双缓冲（double buffer）的数据结构</b>来实现。double buffer同名的概念比较多，这里指的是foreground 和 backgroud 两个buffer进行切换的『0 - 1切换』技术。比如实现动态加载（热加载）配置文件的时候。可能会在切换间隙加一个短暂的互斥量，但是基本可以认为是lock free的。</li></ul><p>我一张口，你就会发现：无非也就是空间换时间的老套路了。</p><h2>spinlock（自旋锁）</h2><p>自旋之名颇为玄妙，第一次听闻常让人略觉高大。但和无数个好似『故意把简单概念复杂化』的计算机术语一样，自旋锁的本质简单的难以置信。</p><p>要了解自旋锁，首先了解自旋。<b>什么是自旋（spin）呢？更为通俗的一个词是『忙等待』（busy waiting）。最最通俗的一个理解，其实就是死循环……</b>。</p><p>单看使用方法和使用互斥量的代码是差不多的。只不过自旋锁不会引起线程休眠。当共享资源的状态不满足的时候，自旋锁会不停地循环检测状态。因为不会陷入休眠，而是忙等待的方式也就不需要条件变量。</p><p>这是优点也是缺点。不休眠就不会引起上下文切换，但是会比较浪费CPU。</p><div class="highlight"><pre><code class="language-c"><span class="c1">// 声明一个自旋锁变量
</span><span class="c1"></span><span class="n">pthread_spinlock_t</span> <span class="n">spinlock</span><span class="p">;</span>

<span class="c1">// 初始化   
</span><span class="c1"></span><span class="n">pthread_spin_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spinlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// 加锁  
</span><span class="c1"></span><span class="n">pthread_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spinlock</span><span class="p">);</span>

<span class="c1">// 解锁 
</span><span class="c1"></span><span class="n">pthread_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spinlock</span><span class="p">);</span>

<span class="c1">// 销毁  
</span><span class="c1"></span><span class="n">pthread_spin_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spinlock</span><span class="p">);</span></code></pre></div><p>pthread_spin_init函数的第二个参数名为pshared（int类型）。表示的是是否能进程间共享自旋锁。这被称之为Thread Process-Shared Synchronization。互斥量的通过属性也可以把互斥量设置成进程间共享的。pshared有两个枚举值：</p><ul><li><b>PTHREAD_PROCESS_PRIVATE：仅同进程下读线程可以使用该自旋锁</b></li><li><b>PTHREAD_PROCESS_SHARED：不同进程下的线程可以使用该自旋锁</b></li></ul><p><b>在Linux上的glibc中这两个枚举值分别是0和1（Mac上不是）。所以通常也会看到直接传0的代码。你可能觉得不使用宏，直接用数字硬编码不是一个好习惯。的确，妥妥的Magic Number，但还有一个有趣的事实你需要了解：</b>并不是所有实现都支持自旋锁设置两种pshared。比如<sup data-text="3" data-url="https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/nptl/pthread_spin_init.c" data-numero="3" data-draft-node="inline" data-draft-type="reference" data-tooltip="3 https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/nptl/pthread_spin_init.c" data-tooltip-preset="white" data-tooltip-classname="ztext-referene-tooltip"><a id="ref_3_0" href="#ref_3" data-reference-link="true" aria-labelledby="ref_3">[3]</a></sup>：</p><div class="highlight"><pre><code class="language-c"><span class="kt">int</span> <span class="nf">pthread_spin_init</span> <span class="p">(</span><span class="n">pthread_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pshared</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Relaxed MO is fine because this is an initializing store.  */</span>
    <span class="n">atomic_store_relaxed</span> <span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">return0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div><p>所以直接传0可能也无伤大雅。</p><p>自旋锁 VS 互斥量+条件变量 孰优孰劣？肯定要看具体的使用场景，（我好像在说片汤话）。当你不知道在你的使用场景下这两种锁该用哪个的时候，那就是用互斥量吧！或者通过压测的判断，不过大多数时候我们好像并不需要这么一个pthread的自旋锁，知友们可以提供一些自旋锁的使用参考。</p><p class="ztext-empty-paragraph"><br></p><p>内容太多，难免有误，望大家指教。</p><hr><h2>课后思考：</h2><p>你还知道哪些锁类型？</p><p>或者哪些线程同步机制（不一定叫锁）？</p><h2>参考</h2><ol class="ReferenceList"><li id="ref_1" tabindex="0"><a class="ReferenceList-backLink" href="#ref_1_0" aria-label="back" data-reference-link="true">^</a><span>1</span>&nbsp;<a href="https://en.wikipedia.org/wiki/Reentrant_mutex#Practical_use" class="external" target="_blank" rel="noopener noreferrer" data-za-detail-view-id="1043">https://en.wikipedia.org/wiki/Reentrant_mutex#Practical_use</a></li><li id="ref_2" tabindex="0"><a class="ReferenceList-backLink" href="#ref_2_0" aria-label="back" data-reference-link="true">^</a><span>2</span>&nbsp;<a href="https://books.google.com.hk/books?id=Ps2SH727eCIC&amp;pg=PA647&amp;lpg=PA647&amp;dq=linux+programming+interface+wait+morphing&amp;source=bl&amp;ots=kMKcz2zPC7&amp;sig=ACfU3U1ZSbxBegrQhuVkfNAMTRkY-YavvA&amp;hl=en&amp;sa=X&amp;redir_esc=y&amp;hl=zh-CN&amp;sourceid=cndr#v=onepage&amp;q=linux%20programming%20interface%20wait%20morphing&amp;f=false" class="external" target="_blank" rel="noopener noreferrer" data-za-detail-view-id="1043">https://books.google.com.hk/books?id=Ps2SH727eCIC&amp;pg=PA647&amp;lpg=PA647&amp;dq=linux+programming+interface+wait+morphing&amp;source=bl&amp;ots=kMKcz2zPC7&amp;sig=ACfU3U1ZSbxBegrQhuVkfNAMTRkY-YavvA&amp;hl=en&amp;sa=X&amp;redir_esc=y&amp;hl=zh-CN&amp;sourceid=cndr#v=onepage&amp;q=linux%20programming%20interface%20wait%20morphing&amp;f=false</a></li><li id="ref_3" tabindex="0"><a class="ReferenceList-backLink" href="#ref_3_0" aria-label="back" data-reference-link="true">^</a><span>3</span>&nbsp;<a href="https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/nptl/pthread_spin_init.c" class="external" target="_blank" rel="noopener noreferrer" data-za-detail-view-id="1043">https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/nptl/pthread_spin_init.c</a></li></ol></span>

