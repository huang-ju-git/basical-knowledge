# java基础

## ● 请你谈谈Java中是如何支持正则表达式操作的？

考察点：正则表达式

### 参考回答：

Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如：

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;
class RegExpTest {
    public static void main(String[] args) {
        String str = "成都市(成华区)(武侯区)(高新区)";
        Pattern p = Pattern.compile(".*?(?=\\()");
        Matcher m = p.matcher(str);
        if(m.find()) {
            System.out.println(m.group());
        }
    }
}
```



## ● 请你简单描述一下正则表达式及其用途。

考察点：正则表达式

### 参考回答：

在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。



## ● 请你比较一下Java和JavaSciprt？

考察：Java&JavaScript

### 参考回答：

JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。
下面对两种语言间的异同作如下比较：
\- 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。
\- 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）
\- 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。
\- 代码格式不一样。



## ● 请你说明一下，在Java中如何跳出当前的多重嵌套循环？

考察点：循环

### 参考回答：

在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）



## ● 请你讲讲&和&&的区别？

考察点：运算符

### 参考回答：

&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals("")，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。



## ● int和Integer有什么区别？

考察点：数据类型

### 参考回答：

Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。
Java 为每个原始类型提供了包装类型：
\- 原始类型: boolean，char，byte，short，int，long，float，double
\- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

如：

class AutoUnboxingTest {
  public static void main(String[] args) {
    Integer a = new Integer(3);
    Integer b = 3;         // 将3自动装箱成Integer类型
    int c = 3;
    System.out.println(a == b);   // false 两个引用没有引用同一对象
    System.out.println(a == c);   // true a自动拆箱成int类型再和c比较
  }
}



## ● 请说明String是最基本的数据类型吗?

考察点：数据类型

### 参考回答：

基本数据类型包括byte、int、char、long、float、double、boolean和short。
java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。





## ● 请你讲讲Java支持的数据类型有哪些？什么是自动拆装箱？

考察点：JAVA数据类型

### 参考回答：

Java语言支持的8种基本数据类型是：
byte
short
int
long
float
double
boolean
char
自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。



## ● 请你说明符号“==”比较的是什么？

考点：基础

### 参考回答：

“==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false。“==”如果两边是基本类型，就是比较数值是否相等。



## ● 请你解释Object若不重写hashCode()的话，hashCode()如何计算出来的？



### 

### String拼接字符串的缺点

String是java中一个不可变的类，一旦被实例化就无法被修改，所以拼接字符串，就是生成了一个新的字符串，即原变量存储了一个新的String对象的引用。可以使用加号，或者String类中的concat方法。也可以使用StringBuilder或者StringBuffer来实现字符串拼接，这两个类的对象是可以修改的。在多线程操作时使用stringBuffer，单线程操作使用StringBuilder。

使用加号进行字符串拼接，是将 String 转成了 StringBuilder 后，使用其 `append` 方法进行处理的。

使用concat()拼接，会首先创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个新的 String 对象并返回。



### String是基本的数据类型吗

String不是基本数据类型，java中的基本数据类型为boolean, byte,short, char, int, long, float, double八种

### StringBuffer是线程安全的吗

是，Stringbuffer大部分方法上都加了synchronize加锁实现的。也因此StringBuffer执行的效率要低于StringBuilder。

### 两个对象equal()之后是不是相等的

equal()默认的行为是比较两个对象的引用，但在大部分java的类库中都重新实现了equals()方法，改成了比较两个对象的实际内容，例如String和Integer等。

### Java锁，synchronized可以修饰静态方法吗

介绍一下wait()

### 使用哪个版本的jdk，有哪些特性

平时主要用java 8。java 8首要的一个新特性是支持lamda表达式和函数接口，用lambda表达式来替换单方法接口，可以把函数当成参数传递给某个方法，简化了一部分需要使用匿名类的场景（这里再去复习一下匿名类的使用场景）最简单的Lambda表达式可由逗号分隔的参数列表、**->**符号和语句块组成。函数接口是为了兼容lambda表达式产生的概念，指的是只有一个函数的接口，这样的接口可以隐式的转化成lambda表达式。Java 8 提供了一个注解**@FunctionalInterface**，来显示的说明函数式接口。

java8的另一个特性是接口中可以定义默认方法和静态方法。接口提供的默认方法会被接口的实现类继承或者重写。这样的目的是可以在不破坏现有兼容性的前提下，往接口中添加新的方法。

java8也引进了新的Date-Time Api 来改进时间，日期的处理。

java8支持重复注解

支持方法引用，通常和lambda表达式结合着使用，没用过不了解







### Java list和set的区别，是否继承自Collection接口

list和set继承自Collection接口，map不是。

list和set分别是collection的两个子接口，区别为：

1. list及其实现类是可变大小的列表，适用于按照数值索引访问元素
2. Set集合无需存储，并且不可以保存重复的元素



### 重载和重写的区别

**重写**：子类在继承父类的时候，在方法名，参数列表，返回类型(除去子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，对父类的方法进行修改或重写。但要注意**子类函数的访问修饰权限不能少于父类的。**

**重载**：在一个类中，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同

区别：重载实现的是编译时的多态性，重写实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型。



### 面向对象的基本特征

面向对象的三个基本特征：

1. **封装**：把客观事物封装成抽象的类，并且类的属性和方法只可以被可信的类或者对象访问，对不可信的隐藏。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。**对于这种隐藏对象属性和实现细节，仅对外公开指定方法来控制程序中属性的访问和修改，我们称之为封装。**

2. **继承**：继承是指可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

   继承的实现方式有两种：实现继承、接口继承。

   实现继承：直接使用基类公开的属性和方法，无需额外编码。

   接口继承：仅使用接口公开的属性和方法名称，需要子类实现。

3. 多态：**多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口**。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。

   原理也很简单，父类或者接口定义的引用变量可以指向子类或者具体实现类的实例对象，由于程序调用方法是在运行期才动态绑定的，那么引用变量所指向的具体实例对象在运行期才确定。所以这个对象的方法是运行期正在内存运行的这个对象的方法而不是引用变量的类型中定义的方法。

   

### HashMap是怎么实现的

哈希冲突：进行数据存储时，通过关键字进行hash得到的地址可能已经存储过数据了，就会出现哈希冲突。

解决哈希冲突的方法有多种，开放定址法，再散列函数法，链地址法等。HashMap即采用了链地址法，也就是数组+链表的形式。数组是HashMap的主体，链表则主要为了解决哈希冲突。在jdk1.8中，HashMap采用数组+链表+红黑树来实现，当链表长度超过阈值时，将链表转化为红黑树，大大减少了查找时间。

待补充 怎么扩容？负载因子是什么



### Java创建对象的不同方式

1. 使用`new`关键字（但使用new创建对象会增加耦合度，所以应该减少，啥叫增加耦合度？？？）

2. 使用反射机制创建对象

   > 反射是指JVM在得到class对象之后，在通过class对象进行反编译，从而获取对象的各种信息。通过反射，可以在运行时动态的创建对象并调用其属性，不需要提前在编译时知道运行的对象是谁。

![image-20210713151818382](java%E5%9F%BA%E7%A1%80.assets/image-20210713151818382.png)

- ​	使用Class类的newInstance方法

  ```java
  Class heroClass = Class.forName("yunche.test.Hello");
  Hello h =(Hello) heroClass.newInstance();
  ```

- 使用Constructor类的newInstance方法

  ```java
  Class heroClass = Class.forName("yunche.test.Hello");
  Constructor constructor = heroClass.getConstructor(int.class, String.class);
  Hello h =(Hello) constructor.newInstance(12, "abc");
  ```

  Class类的`newInstance()`方法是使用该类无参的构造函数创建对象, 如果一个类没有无参的构造函数, 就不能这样创建了,可以调用Class类的getConstructor(String.class,int.class)方法获取一个指定的构造函数，然后再调用Constructor类的newInstance("张三",20)方法创建对象

3. 采用clone

   使用clone创建对象需要有一个已经分配了内存的源对象，创建新对象时，需要首先分配一个和源对象一样大的内存空间。调用clone（）方法需要实现Cloneable接口。

4. 采用序列化机制

   

### 深拷贝与浅拷贝

java中的数据类型分为基本数据类型和引用数据类型，对于这两种数据类型，在进行赋值操作和传递参数或者返回值时，会有值传递和引用传递的差别。

1. **浅拷贝**：对于一个对象中是基本数据类型的成员变量，浅拷贝直接进行值传递，即将该属性值复制一份给新的对象，两个对象间的修改不会互相影响；对于引用类型的成员变量，进行的是引用传递，两个对象的该成员指向同一个实例，两个对象的修改会互相影响。

方法1：通过一个现有的对象创建出与该对象属性相同的新的对象

```java
Age a=new Age(20);
Person p1=new Person(a,"摇头耶稣");
Person p2=new Person(p1);
System.out.println("p1是"+p1);
System.out.println("p2是"+p2);
//修改p1的各属性值，观察p2的各属性值是否跟随变化
p1.setName("小傻瓜");
a.setAge(99);
System.out.println("修改后的p1是"+p1);
System.out.println("修改后的p2是"+p2);
```

输出为：

p1是摇头耶稣 20
p2是摇头耶稣 20
修改后的p1是小傻瓜 99
修改后的p2是摇头耶稣 99

注意，这里对Person类选择了两个具有代表性的属性值：一个是引用传递类型；另一个是字符串类型（属于引用数据类型，但其值无法修改，所以可看做常量），因此不是更改了字符串的值，而是修改了引用指向的字符串。

方法2：通过重写clone()方法进行浅拷贝

重写Cloneable接口，重写clone()方法，通过super.clone()方法调用object类中的原clone方法，因为object类中的clone()方法进行的就是浅拷贝，但被protected修饰，无法直接使用

代码略

2. **深拷贝**：首先介绍对象图的概念。设想一下，一个类有一个对象，其成员变量中又有一个对象，该对象指向另一个对象，另一个对象又指向另一个对象，直到一个确定的实例。这就形成了对象图。那么，对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，**对象进行深拷贝要对整个对象图进行拷贝**。

方法1：通过重写clone()方法进行深拷贝

[Java 浅拷贝和深拷贝的理解和实现方式 - 摇头耶稣 - 博客园 (cnblogs.com)](https://www.cnblogs.com/shakinghead/p/7651502.html)

### **反射机制实现对数据库数据的增、查例子**

### java的不同访问等级

### 什么是java的控制反转



### 对java平台的理解

ava 本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“书写一次，到处运行”（Write once, run anywhere），能够非常容易地获得跨平台能力；另外就是垃圾收集（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。

我们日常会接触到 JRE（Java Runtime Environment）或者 JDK（Java Development Kit）。 JRE，也就是 Java 运行环境，包含了 JVM 和 Java 类库，以及一些模块等。而 JDK 可以看作是 JRE 的一个超集，提供了更多工具，比如编译器、各种诊断工具等。

对于“Java 是解释执行”这句话，这个说法不太准确。我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），然后，在运行时，通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。Java 通过字节码和 Java 虚拟机（JVM）这种跨平台的抽象，屏蔽了操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。



垃圾回收机制相关

## 1.什么是GC？

大白话说就是垃圾回收机制，内存空间是有限的，你创建的每个对象和变量都会占据内存，gc做的就是对象清除将内存释放出来，这就是GC要做的事。

## 2.需要GC的区域

说起垃圾回收的场所，了解过JVM（Java Virtual Machine Model）内存模型的朋友应该会很清楚，堆是Java虚拟机进行垃圾回收的主要场所，其次要场所是方法区。

## 3.堆内存的结构（1.7）

**在JDK1.8之后，堆的永久区取消了
由元空间取代**

Java将堆内存分为3大部分：新生代、老年代和永久代，其中新生代又进一步划分为Eden、S0、S1(Survivor)三个区

**![img](java%E5%9F%BA%E7%A1%80.assets/1863208-20200518213314607-847364411.png)**

## **4.堆内存上对象的分配与回收：**

我们创建的对象会优先在Eden分配，如果是大对象（很长的字符串数组）则可以直接进入老年代。虚拟机提供一个
**-XX:PretenureSizeThreadhold参数**，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝。

另外，**长期存活的对象将进入老年代**，每一次**MinorGC（年轻代GC）**，对象年龄就大一岁，默认15岁晋升到老年代，通过
**-XX:MaxTenuringThreshold设置晋升年龄。**

**堆内存上的对象回收也叫做垃圾回收，那么垃圾回收什么时候开始呢？**

垃圾回收主要是完成**清理对象，整理内存**的工作。上面说到GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代。新生代还分为一个Eden区和两个Survivor区。垃圾回收分为年轻代区域发生的Minor GC和老年代区域发生的Full GC，分别介绍如下。

**Minor GC（年轻代GC）:**
对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快。

**Full GC（老年代GC）:**
Full GC是指发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。

[MinorGC和FullGC的触发条件](https://www.cnblogs.com/leeego-123/p/11298342.html)

**动态对象年龄判定：**

如果Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，那么**年龄大于等于该对象年龄的对象即可晋升**到老年代，不必要等到-XX:MaxTenuringThreshold。

**空间分配担保：**

发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。如果大于，则进行一次**Full GC（老年代GC）**，如果小于，则查看**HandlePromotionFailure设置是否允许担保失败**，如果允许，那只会进行一次**Minor GC**，如果不允许，则改为进行一次**Full GC**。

## **5.目前会问到的****问题**

### **1.年轻代三个区比例**

Eden，S0，S1比例8:1:1

### 2.为什么要有Survivor区

链接：https://www.jianshu.com/p/2caad185ee1f

为什么需要Survivor空间。我们看看如果没有 Survivor 空间的话，垃圾收集将会怎样进行：一遍新生代 gc 过后，不管三七二十一，活着的对象全部进入老年代，即便它在接下来的几次 gc 过程中极有可能被回收掉。这样的话老年代很快被填满， Full GC 的频率大大增加。我们知道，老年代一般都会被规划成比新生代大很多，对它进行垃圾收集会消耗比较长的时间；如果收集的频率又很快的话，那就更糟糕了。基于这种考虑，虚拟机引进了“幸存区”的概念：如果对象在某次新生代 gc 之后任然存活，让它暂时进入幸存区；以后每熬过一次 gc ，让对象的年龄＋1，直到其年龄达到某个设定的值（比如15岁）， JVM 认为它很有可能是个“老不死的”对象，再呆在幸存区没有必要（而且老是在两个幸存区之间反复地复制也需要消耗资源），才会把它转移到老年代。

Survivor的存在意义，**就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。**

### 3.为什么有两个Survivor区

**为什么 Survivor 分区不能是 1 个？**

如果 Survivor 分区是 1 个的话，假设我们把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。

但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。

**为什么 Survivor 分区是 2 个？**

刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（**这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生**）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。下图中每部分的意义和上一张图一样，就不加注释了。
![两块Survivor避免碎片化](java%E5%9F%BA%E7%A1%80.assets/20160516174938778)
上述机制最大的好处就是，整个过程中，**永远有一个survivor space是空的，另一个非空的survivor space无碎片**。

那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满

**总结**

根据上面的分析可以得知，当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的，所以这也是为什么 Survivor 分区是 2 个的原因了。

## 6. **JVM如何判定一个对象是否应该被回收？（重点掌握）**

 判断一个对象是否应该被回收，主要是看其是否还有引用。判断对象是否存在引用关系的方法包括**引用计数法以及可达性分析**。

### **引用计数法：**

是一种比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为0的对象。此算法最致命的是**无法处理循环引用**的问题。

### ***\*可达性分析\**：**

**可达性分析**的基本思路就是通过一系列可以做为root的对象作为起始点，从这些节点开始向下搜索。当一个对象到root节点没有任何引用链接时，则证明此对象是可以被回收的。以下对象会被认为是root对象：

- **栈内存中引用的对象** 
- **方法区中静态引用和常量引用指向的对象** 
- 被启动类（bootstrap加载器）加载的类和创建的对象
- Native方法中JNI引用的对象。 

## 7. **JVM垃圾回收算法有哪些？**

HotSpot 虚拟机采用了**可达性分析**来进行内存回收，常见的回收算法有**标记-清除算法，复制算法和标记整理算法。**

**标记-清除算法（Mark-Sweep）：**

标记-清除算法执行分两阶段。

第一阶段：从引用根节点开始标记所有被引用的对象，

第二阶段：遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，并且会产生内存碎片。

 ![img](java%E5%9F%BA%E7%A1%80.assets/1863208-20200518220833632-972373317.png)

 

 缺点：

- 执行效率不稳定，会因为对象数量增长，效率变低
- 标记清除后会有大量的不连续的内存碎片，空间碎片太多就会导致无法分配较大对象，无法找到足够大的连续内存，而发生gc

**复制算法：**

复制算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。复制算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。

 ![img](java%E5%9F%BA%E7%A1%80.assets/1863208-20200518220842922-1689223689.png)

 

 缺点：

- 可用内存缩成了一半，浪费空间

**标记-整理算法：**

标记-整理算法结合了**“标记-清除”和“复制”**两个算法的优点。也是分两阶段，

第一阶段从根节点开始标记所有被引用对象，

第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。

 ![img](java%E5%9F%BA%E7%A1%80.assets/1863208-20200518220853967-2126721751.png)

 

 

## 8.垃圾收集器（掌握CMS和G1）

JVM中的垃圾收集器主要包括7种，即**Serial，Serial Old，ParNew，Parallel Scavenge，Parallel Old以及CMS，G1收集器**。如下图所示：

 ![img](java%E5%9F%BA%E7%A1%80.assets/1863208-20200518221710647-576582447.png)

 

**1、Serial收集器：**

Serial收集器是**一个单线程的垃圾收集器**，并且在执行垃圾回收的时候需要 **Stop The World**。虚拟机运行在**Client模式**下的默认新生代收集器。Serial收集器的优点是简单高效，对于限定在单个CPU环境来说，Serial收集器没有多线程交互的开销。

**2、Serial Old收集器：**

Serial Old是Serial收集器的老年代版本，也是**一个单线程收集器**。主要也是给在Client模式下的虚拟机使用。在Server模式下存在主要是做为CMS垃圾收集器的后备预案，**当CMS并发收集发生Concurrent Mode Failure时使用。**

**3、ParNew收集器：**

ParNew是Serial收集器的**多线程**版本，新生代是并行的（多线程的），老年代是串行的（单线程的），新生代采用复制算法，老年代采用标记整理算法。可以使用参数：**-XX：UseParNewGC使用该收集器，使用 -XX：ParallelGCThreads可以限制线程数量。**

**4、Parallel Scavenge垃圾收集器：**

Parallel Scavenge是一种新生代收集器，使用复制算法的收集器，而且是**并行的多线程收集器。**Paralle收集器特点是更加关注吞吐量（吞吐量就是cpu用于运行用户代码的时间与cpu总消耗时间的比值）。可以通过**-XX:MaxGCPauseMillis参数控制最大垃圾收集停顿时间；通过-XX:GCTimeRatio参数直接设置吞吐量大小；通过-XX:+UseAdaptiveSizePolicy参数可以打开GC自适应调节策略，**该参数打开之后虚拟机会根据系统的运行情况收集性能监控信息，动态调整虚拟机参数以提供最合适的停顿时间或者最大的吞吐量。**自适应调节策略**是Parallel Scavenge收集器和ParNew的主要区别之一。

**5、Parallel Old收集器：**

Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。

### **6、CMS（Concurrent Mark Sweep）收集器（并发标记清除）**

CMS收集器是**一种以获取最短回收停顿时间为目标**的收集器。CMS收集器是基于**标记-清除算法**实现的，是一种老年代收集器，通常与**ParNew**一起使用。

**CMS的垃圾收集过程分为4步：**

- **初始标记**：需要“Stop the World”，初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快。
- **并发标记**：是主要标记过程，这个标记过程是和用户线程并发执行的。
- **重新标记**：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。
- **并发清除**：和用户线程并发执行的，基于标记结果来清理对象。

 ![img](java%E5%9F%BA%E7%A1%80.assets/1863208-20200518221735413-1771145268.png)

 

 

那么问题来了，**如果在重新标记之前刚好发生了一次MinorGC，会不会导致重新标记阶段Stop the World时间太长？**

答：不会的，在并发标记阶段其实还包括了一次并发的**预清理阶段**，虚拟机会主动**等待年轻代发生垃圾回收**，这样可以将重新标记对象引用关系的步骤放在并发标记阶段，有效降低重新标记阶段Stop The World的时间。

#### **CMS垃圾回收器的优缺点分析：**

CMS以降低垃圾回收的停顿时间为目的，很显然其具有并发收集，停顿时间低的优点。

#### **缺点主要包括如下：**

- **对CPU资源非常敏感**，因为并发标记和并发清理阶段和用户线程一起运行，当CPU数变小时，性能容易出现问题。
- 收集过程中会产生**浮动垃圾**，所以不可以在老年代内存不够用了才进行垃圾回收，必须提前进行垃圾收集。通过参数**-XX:CMSInitiatingOccupancyFraction**的值来控制内存使用百分比。如果该值设置的太高，那么在CMS运行期间预留的内存可能无法满足程序所需，会出现**Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器**，会产生更长时间的停顿。
- **标记-清除方式会产生内存碎片**，可以使用参数**-XX：UseCMSCompactAtFullCollection**来控制是否开启内存整理（无法并发，默认是开启的）。参数**-XX:CMSFullGCsBeforeCompaction**用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。

接下来，我们先看下上边介绍的浮动垃圾是怎么产生的吧。

**浮动垃圾：**

由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了**“Floating Garbage”**，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，**并发收集器一般需要20%的预留空间**用于这些浮动垃圾。

**7、G1（Garbage-First）收集器：**

G1收集器将新生代和老年代取消了，取而代之的是**将堆划分为若干的区域**，每个区域都可以根据需要扮演新生代的Eden和Survivor区或者老年代空间，仍然属于分代收集器，区域的一部分包含新生代，新生代采用复制算法，老年代采用标记-整理算法。

通过**将JVM堆分为一个个的区域（region）**,G1收集器可以避免在Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次**根据回收时间来优先回收价值最大的region。**

**G1收集器的特点：**

- **并行与并发**：G1能充分利用多CPU，多核环境下的硬件优势，来缩短Stop the World，是并发的收集器。
- **分代收集**：G1不需要其他收集器就能独立管理整个GC堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次GC的对象。
- **空间整合**：G1从整体来看是基于标记-整理算法，从局部（两个Region）上看基于复制算法实现，G1运作期间不会产生内存空间碎片。
- **可预测的停顿**：能够建立可以预测的停顿时间模型，预测停顿时间。

**和CMS收集器类似，G1收集器的垃圾回收工作也分为了四个阶段：**

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

其中，筛选回收阶段首先对各个Region的回收价值和成本进行计算，根据用户期望的GC停顿时间来制定回收计划。

